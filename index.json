[{"categories":["Kubernetes"],"content":"前提条件 一个 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版提供了通用的说明。 每个机器至少 2GB 的内存。 至少 2 个 CPU 集群中所有机器之间的网络连接，公网或内网都可以。 每个节点由唯一的主机名，MAC 地址。 指定的端口在机器上是开放的。点击这里查看具体信息。 禁用 Swap。为了使 kubectl 正常工作，必须禁用 swap。 ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:1:0","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"让 iptables 能发现桥接网络的流量 确保 br_netfilter 模块被装载了。可以通过以下命令来完成： lsmod | grep br_netfilter # br_netfilter 22256 0 # bridge 151336 2 br_netfilter,ebtable_broute sudo modprobe br_netfilter 为了让 Linux 节点的 iptables 能正确的观测到桥接流量，需要保证 net.bridge.bridge-nf-call-iptables 被设置为1： sudo tee /etc/sysctl.d/kubernetes.conf\u003c\u003cEOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:1:1","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"检查需要的端口 ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:1:2","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"安装 Docker 参考：Install Docker Engine on CentOS ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:1:3","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"安装 Kubernetes ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:2:0","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"准备 Kubernetes 服务器 服务器类型 主机名 具体信息 Master 192.168.2.60 2 CPUs, 2GB Ram Worker 192.168.2.61 2 CPUs, 2GB Ram Worker 192.168.2.62 2 CPUs, 2GB Ram ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:2:1","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"安装 kubelet 和 kubeadm cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:2:2","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"禁用 SELinux 和 Swap # Set SELinux in permissive mode (effectively disabling it) sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config # Disable swap sudo sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab sudo swapoff -a ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:2:3","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"配置防火墙 启用 Master 节点端口: sudo firewall-cmd --add-port={6443,2379-2380,10250,10251,10252,5473,179,5473}/tcp --permanent sudo firewall-cmd --add-port={4789,8285,8472}/udp --permanent sudo firewall-cmd --reload 启用 Worker 节点端口: sudo firewall-cmd --add-port={10250,30000-32767,5473,179,5473}/tcp --permanent sudo firewall-cmd --add-port={4789,8285,8472}/udp --permanent sudo firewall-cmd --reload ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:3:0","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"验证安装是否成功 为了验证安装是否成功，我们准备用 kubeadm 创建一个 cluster。 ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:4:0","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"初始化 Kubernetes Control Plane (K8s 控制平面) 首先，向 /etc/hosts 中添加下面的主机名： 192.168.2.60 k8s-master01 k8s-master01.torres.com 然后运行以下命令来初始化 master 节点的 control plane： # (Optional) You can run this commands to verify the connection with gcr.io sudo kubeadm config images pull # Init Control plane sudo kubeadm init --control-plane-endpoint=k8s-master01.torres.com --node-name=k8s-master01 --upload-certs 然后可以看到以下的日志： [init] Using Kubernetes version: v1.21.1 [preflight] Running pre-flight checks [WARNING Firewalld]: firewalld is active, please ensure ports [6443 10250] are open or your cluster may not function correctly [WARNING IsDockerSystemdCheck]: detected \"cgroupfs\" as the Docker cgroup driver. The recommended driver is \"systemd\". Please follow the guide at https://kubernetes.io/docs/setup/cri/ [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' [certs] Using certificateDir folder \"/etc/kubernetes/pki\" [certs] Generating \"ca\" certificate and key [certs] Generating \"apiserver\" certificate and key [certs] apiserver serving cert is signed for DNS names [k8s-master01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local localhost.localdomain] and IPs [10.96.0.1 192.168.2.60] [certs] Generating \"apiserver-kubelet-client\" certificate and key [certs] Generating \"front-proxy-ca\" certificate and key [certs] Generating \"front-proxy-client\" certificate and key [certs] Generating \"etcd/ca\" certificate and key [certs] Generating \"etcd/server\" certificate and key [certs] etcd/server serving cert is signed for DNS names [localhost localhost.localdomain] and IPs [192.168.2.60 127.0.0.1 ::1] [certs] Generating \"etcd/peer\" certificate and key [certs] etcd/peer serving cert is signed for DNS names [localhost localhost.localdomain] and IPs [192.168.2.60 127.0.0.1 ::1] [certs] Generating \"etcd/healthcheck-client\" certificate and key [certs] Generating \"apiserver-etcd-client\" certificate and key [certs] Generating \"sa\" key and public key [kubeconfig] Using kubeconfig folder \"/etc/kubernetes\" [kubeconfig] Writing \"admin.conf\" kubeconfig file [kubeconfig] Writing \"kubelet.conf\" kubeconfig file [kubeconfig] Writing \"controller-manager.conf\" kubeconfig file [kubeconfig] Writing \"scheduler.conf\" kubeconfig file [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Starting the kubelet [control-plane] Using manifest folder \"/etc/kubernetes/manifests\" [control-plane] Creating static Pod manifest for \"kube-apiserver\" [control-plane] Creating static Pod manifest for \"kube-controller-manager\" [control-plane] Creating static Pod manifest for \"kube-scheduler\" [etcd] Creating static Pod manifest for local etcd in \"/etc/kubernetes/manifests\" [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \"/etc/kubernetes/manifests\". This can take up to 4m0s [apiclient] All control plane components are healthy after 13.004835 seconds [upload-config] Storing the configuration used in ConfigMap \"kubeadm-config\" in the \"kube-system\" Namespace [kubelet] Creating a ConfigMap \"kubelet-config-1.21\" in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Storing the certificates in Secret \"kubeadm-certs\" in the \"kube-system\" Namespace [upload-certs] Using certificate key: b8cb86fb2bd01029d07cd1c67a6ae9ca358655595cef1cc7bec5253b64a81037 [mark-control-plane] Marking the node localhost.localdomain as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers] [mark-control-plane] Marking the node localhos","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:4:1","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Kubernetes"],"content":"验证 运行以下指令来验证集群是否初始化成功： kubectl cluster-info Kubernetes control plane is running at https://k8s-master01:6443 CoreDNS is running at https://k8s-master01:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 如果你还想看有哪些节点： kubectl get nodes NAME STATUS ROLES AGE VERSION localhost.localdomain NotReady control-plane,master 3m15s v1.21.1 ","date":"2021-10-02","objectID":"/2021/10/kubenetes-on-centos/:4:2","tags":["Cloud Native","Kubernetes"],"title":"Kubenetes on Centos","uri":"/2021/10/kubenetes-on-centos/"},{"categories":["Programming"],"content":"Hello Golang Golang 是由 Google 开发并开源出来的一种编程语言，Kubernetes 就是由 Go 主要开发的，由此可见 Go 在云原生开发中的重要地位。在这里我们主要介绍 Golang 的基础知识，例如各种语法，数据结构，以及一些 Tips。 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:1:0","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"声明和赋值 Go 中声明变量和给变量赋值的方法和 JavaScript 比较相似。如下： // var 是声明变量的关键字，如果只声明变量而不给它赋值 // 则该变量会被赋值为该类型的零值（zero value） var num int // := 是声明并赋值的操作符 // 其工作流程为： // 1. 声明一个名为 num 的变量 // 2. 将 10 赋值给变量 num num := 10 但是要注意的是，每个类型的零值不相同，比如说 int 的零值为 0，浮点类型的零值为 0.0，而 string 的零值为空字符串：\"\"… 如 struct 或者指针类型的变量，零值为 nil。 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:2:0","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"基础数据类型 Go 的基础数据类型和其他的编程语言相似，在这里我们介绍一下 Go 中的整型、字符串、浮点型、布尔型等： ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:3:0","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"整型 有符号整型： 类型 大小 范围 int8 8 bits -128 to 127 int16 16 bits -215 to 215 -1 int32 32 bits -231 to 231 -1 int64 64 bits -263 to 263 -1 int 取决于平台 取决于平台 int 的大小取决于平台，在32位系统中它是32位的，而在64位系统中，它是64位。 无符号整型： 类型 大小 范围 uint8 8 bits 0 to 255 uint16 16 bits 0 to 216 -1 uint32 32 bits 0 to 232 -1 uint64 64 bits 0 to 264 -1 uint 取决于平台 取决于平台 uint 和 int 的大小一样取决于所在的平台。 提示：当你使用 integer 类型的值时，除非你有更好的原因去使用无符号整型或者带位数的整型类型，否则请使用 int . Golang 中还有两个额外的类型可以表示整型： 类型 表示为 byte uint8 rune int32 在 Go 中，rune 和 byte是用来区分字符和整型类型的。Go 中没有 char 类型，它用 rune 和 byte 来表示字符（但是它们本质上都是整数类型）： var firstLetter = 'A' // Type inferred as `rune` (Default type for character values) var lastLetter byte = 'Z' 而 byte 可以转换成 ASCII 码中对应的数字，如 firstLetter 可以转换成 65。rune 变量能转换为 Unicode 中对应的编码。 package main import \"fmt\" func main() { var myByte byte = 'a' var myRune rune = '♥' fmt.Printf(\"%c = %d and %c = %U\\n\", myByte, myByte, myRune, myRune) } # Output a = 97 and ♥ = U+2665 可以看到 a 被转成了 97，Unicode 值 ‘♥’ 被转换成了对应的 Unicode 码：U+2665。U 代表 Unicode，后面的数字则是16进制的整数。 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:3:1","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"浮点型 浮点类型的数字包括两种： float32：在内存中占用 32 bits，以单精度浮点格式存储值。 float64：在内存中占用 64 bits，以双精度浮点格式存储值。 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:3:2","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"集合类型 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:4:0","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"数组 在 Go 中，数组是固定长度的数据类型，包含相同类型元素的连续内存块。定义数组的代码如下： // 声明一个长度为5的数组，默认初始化每个元素为0（参考上面说到的零值） var arr [5]int // 声明并初始化一个长度为5的数组 arr := [5]int{1,2,3,4,5} // 声明一个int数组，Go会基于初始化元素的个数来决定其长度 arr := [...]int{1,2,3} // 声明一个长度为5的int数组，但是只初始化指定位置的元素 arr := [5]int{1: 20, 3: 40} 注意： 数组只要被声明之后，就无法再更改其长度和类型了。 在 functions 之间传递数组是非常昂贵的，如果是在需要传递数组，可以考虑传递它的指针。 声明一个一百万个元素的 int 数组，在64位操作系统上会占用 8MB 内存。 而在 function 之间传递时，每调用一次 function，都会在栈中分配一个 8MB 的空间给这个数组。 而传递这个数组的指针则会更高效，指针对象只会占用8个字节空间。 ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:4:1","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"Slice ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:4:2","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"},{"categories":["Programming"],"content":"Map ","date":"2021-10-02","objectID":"/2021/10/golang-fundamentals/:4:3","tags":["Golang"],"title":"Golang 基础知识","uri":"/2021/10/golang-fundamentals/"}]